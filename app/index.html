<!DOCTYPE html>
<html>
<head>
  <title>Trabalho de Linguagens Formais e Autômatos</title>
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="assets/css/style.css">
</head>
<body>
<header>
  <h1>Trabalho de Linguagens Formais e Autômatos</h1>
  <h2>Prof. Celso Olivette</h2>
  <h3>Fábio da Silva Takaki e Lucas Martins Valladares Ribeiro</h3>
</header>
<div class="container">
  <div class="col-ferramentas">
    <h3>Ferramentas</h3>
    <button id="help">Ajuda</button>
    <form>
      <input type="radio" name="tool" value="node" checked> Estados<br>
      <input type="radio" name="tool" value="initial"> Estados Inicial<br>
      <input type="radio" name="tool" value="end"> Estado Final<br>
      <input type="radio" name="tool" value="change_label"> Mudar elemento de transição<br>
      <input type="radio" name="tool" value="eraser"> Deletar  
    </form>
    <h3>Algoritmos</h3>
    <h4>Testar diretamente</h4>
    String: <input type="text" name="string" id="string_direct" /> <button id="direct">Testar diretamente</button>

    <h4>Múltiplas Entradas</h4>
    <button id="add_input">Adicionar entrada</button>
    <br>
    <div id="multiple_inputs"></div>

    <h4>Step-by-step</h4>
    String: <input type="text" name="string_step" id="string_step" />
    <button id="step">Iniciar</button>
<<<<<<< HEAD
    <div id="path"></div>
=======

    <h4>Expressões regulares</h4>
    <h5>Expressão</h5>
    <input type="text" name="expression" id="expression" />
    <h5>String para teste</h5>
    <input type="text" name="string_expression" id="string_expression" />
>>>>>>> 740a52a93348cabda3ba7ac9001f0bcc5ea2eea4

    <h4>Gramática Regular</h4>
    <h5>Símbolos separados por vírgula</h5>
    <input type="text" placeholder="Ex: S,A,B,C"><br>
    <div id="multiple_grammar"></div>
    <button id="add_rule">Adicionar regra</button>
    <h5>String para teste</h5>
    <input type="text" id="string_grammar" /><button id="grammar_test">Testar</button>
  </div>
  <div class="col">
    <div id="cy"></div>
  </div>
</div>

<footer>Copyright &copy; 2017 - FCT UNESP :)</footer>
<script type="text/javascript" src="assets/js/cytoscape/cytoscape.min.js"></script>
<script type="text/javascript" src="assets/js/cytoscape-edgehandles/cytoscape-edgehandles.js"></script>
<script type="text/javascript" src="assets/js/jquery-3.1.1.min.js"></script>

<script type="text/javascript">
  // -------------------------
  // AJUDA
  // -------------------------
  $('#help').click(function(event) {
    alert('Legenda:\n Triângulo: Evento Inicial. \n Losango: Evento Final \n Estrela: Evento Inicial e Final.');
  });

  // -------------------------
  // Definições CYTOSCAPE
  // -------------------------
  var cy = cytoscape({

    container: $('#cy'), // container to render in

    elements: [],

    style: [ // the stylesheet for the graph
      {
        selector: 'node',
        style: {
          'width':40,
          'height':40,
          'background-color': '#666',
          'label': 'data(id)'
        }
      },

      {
        selector: 'edge',
        style: {
          'width': 1,
          'label':'data(label)',
          'target-arrow-shape': 'triangle',
          'line-color': '#333',
          'target-arrow-color': '#333',
          'curve-style': 'bezier'
        }
      }
    ],

    layout: {
      name: 'grid',
      rows: 1
    }

  });
  //Math.floor((Math.random() * 1000) + 1)


  // the default values of each option are outlined below:
  var defaults = {
    preview: true, // whether to show added edges preview before releasing selection
    stackOrder: 4, // Controls stack order of edgehandles canvas element by setting it's z-index
    handleSize: 10, // the size of the edge handle put on nodes
    handleColor: '#ff0000', // the colour of the handle and the line drawn from it
    handleLineType: 'ghost', // can be 'ghost' for real edge, 'straight' for a straight line, or 'draw' for a draw-as-you-go line
    handleLineWidth: 1, // width of handle line in pixels
    handleIcon: false, // Pass an Image-object to use as icon on handle. Icons are resized according to zoom and centered in handle.
    handleNodes: 'node', // selector/filter function for whether edges can be made from a given node
    hoverDelay: 150, // time spend over a target node before it is considered a target selection
    cxt: false, // whether cxt events trigger edgehandles (useful on touch)
    enabled: true, // whether to start the extension in the enabled state
    toggleOffOnLeave: true, // whether an edge is cancelled by leaving a node (true), or whether you need to go over again to cancel (false; allows multiple edges in one pass)
    edgeType: function( sourceNode, targetNode ) {
      // can return 'flat' for flat edges between nodes or 'node' for intermediate node between them
      // returning null/undefined means an edge can't be added between the two nodes
      return 'flat';
    },
    loopAllowed: function( node ) {
      // for the specified node, return whether edges from itself to itself are allowed
      return true;
    },
    nodeLoopOffset: -50, // offset for edgeType: 'node' loops
    nodeParams: function( sourceNode, targetNode ) {
      // for edges between the specified source and target
      // return element object to be passed to cy.add() for intermediary node
      return {};
    },
    edgeParams: function( sourceNode, targetNode, i ) {
      // for edges between the specified source and target
      // return element object to be passed to cy.add() for edge
      // NB: i indicates edge index in case of edgeType: 'node'
      //return {data: { id: sourceNode.data('id')+targetNode.data('id')+Math.floor((Math.random() * 1000) + 1), source: sourceNode.data('id'), target: targetNode.data('id')}};
      return {};
    },
    start: function( sourceNode ) {
      // fired when edgehandles interaction starts (drag on handle)
    },
    complete: function( sourceNode, targetNodes, addedEntities ) {
      // fired when edgehandles is done and entities are added
      var text = prompt('Digite o caractere', "");
      if(text == "") text = "λ";
      if(text.length > 1) text = "λ";
      addedEntities.data('label', text);
    },
    stop: function( sourceNode ) {
      // fired when edgehandles interaction is stopped (either complete with added edges or incomplete)
    }
  };
  cy.edgehandles( defaults );

  
  // -------------------------
  // FERRAMENTAS
  // -------------------------
  // variavel para inserção de nós identificar id
  var q = 0;

  // variavel para identificar se ja existe estado inicial ou não
  var initial = 0;

  // manipulo a variavel tool para saber qual ferramenta vai ser utilizada abaixo
  var tool = 0;
  $(document).ready(function() {
    $('input[type=radio]').change(function() {
      if(this.value == 'node'){
        tool = 0;
      }
      if (this.value == 'initial') {
        tool = 1;
      }
      if (this.value == 'end') {
        tool = 2;
      }
      if (this.value == 'change_label') {
        tool = 3;
      }
      else if (this.value == 'eraser') {
        tool = 20;
      }
    });
  });

  cy.on('tap', function(event){
    
    // inserção de nós
    if(tool == 0){
      var elm = $(this);
      cy.add({
        group: "nodes",
        data: { id: "q"+q },
        position: { 
          x: event.cyPosition.x, 
          y: event.cyPosition.y
        },

      });
      q++;
    }

    // estados iniciais
    if(tool == 1){
      if(event.cyTarget != cy){ // verifico se clicou em um elemento
        if(event.cyTarget.isNode()){ // verifico se é um node
          if(event.cyTarget.style().shape == "triangle"){
            event.cyTarget.style({shape:'ellipse'});
            initial = 0;
          }
          else if(event.cyTarget.style().shape == "star"){
            event.cyTarget.style({shape:'diamond'});
            initial = 0;
          }
          else if(event.cyTarget.style().shape == "diamond"){
            if(initial == 0){
              event.cyTarget.style({shape:'star'});
              initial = 1;
            }else{
              alert('Já existe um estado inicial.');
            }
          }
          else{
            if(initial == 0){
              event.cyTarget.style({shape:'triangle'});
              initial = 1;
            }else{
              alert('Já existe um estado inicial.');
            }
          }
        }
      }
    }

    //estados finais
    if(tool == 2){
      if(event.cyTarget != cy){ // verifico se clicou em um elemento
        if(event.cyTarget.isNode()){ // verifico se é um node
          if(event.cyTarget.style().shape == "triangle"){
            event.cyTarget.style({shape:'star'});
          }
          else if(event.cyTarget.style().shape == "star"){
            event.cyTarget.style({shape:'triangle'});
          }
          else if(event.cyTarget.style().shape == "diamond"){
            event.cyTarget.style({shape:'ellipse'});
          }
          else{
            event.cyTarget.style({shape:'diamond'});
          }
        }
      }
    }    


    //muda elemento de transição
    if(tool == 3){
      if(event.cyTarget != cy){ // verifico se clicou em um elemento
        if(event.cyTarget.isEdge()){ // verifico se é um node
          var text = prompt('Digite o caractere', "");
          if(text == "") text = "λ";
          if(text.length > 1) text = "λ";
          event.cyTarget.data('label', text);
        }
      }
    }

    // deleta elementos
    if(tool == 20){
      if(event.cyTarget != cy){
        console.log( 'tap ' + event.cyTarget.id() );
        // se for um estado inicial, eu reseto a variavel initial
        if(event.cyTarget.style().shape == "triangle") initial = 0;
        event.cyTarget.remove();
      }
    }

  });

  // -------------------------
  // TESTE DIRETO
  // -------------------------
  var visit = function(index, estado, string_text){
    if(string_text.length == 0){
        for(var i=0; i<cy.elements().size(); i++){
        var edge = cy.elements()[i];
        if(edge.isEdge()){
          console.log(edge.data('label'));
          console.log(string_text[index]);
          if(edge.data('label') == "λ"){
              return true;
          }
        }
      }
    }

    if(index == string_text.length){
      if(estado.style('shape') == 'diamond' || estado.style('shape') == 'star'){
        return true;
      }else{ return false; }
    }

    for(var i=0; i<cy.elements().size(); i++){
      var edge = cy.elements()[i];
      if(edge.isEdge()){
        console.log(edge.data('label'));
        console.log(string_text[index]);
        if(edge.source().id() == estado.id() && edge.data('label') == string_text[index]){
          index++;
          if(visit(index, edge.target(), string_text)){
            return true;
          }else{
            index--;
          }
        }
      }
    }

    return false;
  }

  $('#direct').click(function(event) {
    var nodeRoot;
    // pego o evento inicial
    for(var i=0; i<cy.elements().size(); i++){
      if(cy.elements()[i].style('shape') == 'triangle' || cy.elements()[i].style('shape') == 'star'){
        nodeRoot = cy.elements()[i];
      }
    }

    if(nodeRoot === undefined){
      alert('Estado inicial não definido.');
    }

    for(var i=0; i<cy.elements().size(); i++){
      var element = cy.elements()[i];
      if(element.isNode()){
        element.style('background-color', '#666');
      }
    }

    // split na string que quero testar
    var string_text = $('#string_direct').val().split('');
    console.log(string_text);

    var index=0;
    if(visit(index, nodeRoot, string_text)){
      alert('String é válida');
    }else{
      alert('String NÃO válida');
    }

  });


  // -------------------------
  // STEP-BY-STEP
  // -------------------------

  var array = [];

  var parray = function(){
    var print='';
    print = array[0];
    for(var i=1; i<array.length; i++){
      print = print+'->'+array[i];
    }
    return print;
  }

  var cleararray = function(){
    array = [];
  }

  var step = function(index, estado, string_text){
<<<<<<< HEAD
        if(string_text.length == 0){
          for(var i=0; i<cy.elements().size(); i++){
          var edge = cy.elements()[i];
          if(edge.isEdge()){
            if(edge.data('label') == "λ"){
              estado.style('background-color', 'blue');
              edge.target().style('background-color', 'blue');
              array.push(estado.id());
              alert(parray());
              return true;
            }
=======
      if(string_text.length == 0){
        for(var i=0; i<cy.elements().size(); i++){
        var edge = cy.elements()[i];
        if(edge.isEdge()){
          if(edge.data('label') == "λ"){
            estado.style('background-color', 'blue');
            edge.target().style('background-color', 'blue');
            return true;
>>>>>>> 740a52a93348cabda3ba7ac9001f0bcc5ea2eea4
          }
        }
      }
    }

<<<<<<< HEAD
      if(index == string_text.length){
        if(estado.style('shape') == 'diamond' || estado.style('shape') == 'star'){
=======
    if(index == string_text.length){
      if(estado.style('shape') == 'diamond' || estado.style('shape') == 'star'){
        if(confirm('Finalizando em: '+estado.id())){
>>>>>>> 740a52a93348cabda3ba7ac9001f0bcc5ea2eea4
          estado.style('background-color', 'blue');
          return true;
        }else{ return false; }
      }else{ estado.style('background-color', '#666'); return false; }
    }

<<<<<<< HEAD
      for(var i=0; i<cy.elements().size(); i++){
        var edge = cy.elements()[i];
        if(edge.isEdge()){
          if(edge.source().id() == estado.id() && edge.data('label') == string_text[index]){
            index++;
            array.push(edge.target().id());
            alert(parray());
=======
    for(var i=0; i<cy.elements().size(); i++){
      var edge = cy.elements()[i];
      if(edge.isEdge()){
        if(edge.source().id() == estado.id() && edge.data('label') == string_text[index]){
          index++;
          if(confirm('Passando por: '+edge.target().id())){
>>>>>>> 740a52a93348cabda3ba7ac9001f0bcc5ea2eea4
            if(step(index, edge.target(), string_text)){
              estado.style('background-color', 'blue');
              return true;
            }else{
              array.pop();
              alert(parray());
              index--;
            }
          }
        }else{
          return false;
        }
      }
<<<<<<< HEAD
      estado.style('background-color', '#666');
      return false;
=======
    }
    estado.style('background-color', '#666');
    return false;
>>>>>>> 740a52a93348cabda3ba7ac9001f0bcc5ea2eea4
  }

  $('#step').click(function(event) {
    var nodeRoot;
    // pego o evento inicial
    for(var i=0; i<cy.elements().size(); i++){
      if(cy.elements()[i].style('shape') == 'triangle' || cy.elements()[i].style('shape') == 'star'){
        nodeRoot = cy.elements()[i];
      }
    }

    if(nodeRoot === undefined){
      alert('Estado inicial não definido.');
    }

    for(var i=0; i<cy.elements().size(); i++){
      var element = cy.elements()[i];
      if(element.isNode()){
        element.style('background-color', '#666');
      }
    }

    nodeRoot.style('background-color', 'blue');
    array.push(nodeRoot.id());
    alert(parray());

    var string_text = $('#string_step').val().split('');
    step(0, nodeRoot, string_text);
    cleararray();
  });

  // -------------------------
  // expressões regulares
  // -------------------------
  function callTester() {
    var string1 = document.getElementById("string_expression").value;
    var re = new RegExp(document.getElementById("expression").value);
    
    if (re.test(string1)) {
      console.log("Valido");
      document.getElementById("string_expression").style.border = "2px solid green"; 
    } else {
      console.log("Invalido");
      document.getElementById("string_expression").style.border = "2px solid red"; 
    }
  }

  document.getElementById("expression").addEventListener("keyup", callTester);
  document.getElementById("string_expression").addEventListener("keyup", callTester);

  // -------------------------
  // múltiplas entradas
  // -------------------------
  var id_multiple=1;
  $('#add_input').click(function(event) {
    $('<br><input type="text" id="multiple_"'+id_multiple+' />').appendTo('#multiple_inputs');
    id_multiple++;

    $('#multiple_inputs input').each(function(index, el) {
      $(el).keyup(function() {
        var nodeRoot;
        // pego o evento inicial
        for(var i=0; i<cy.elements().size(); i++){
          if(cy.elements()[i].style('shape') == 'triangle' || cy.elements()[i].style('shape') == 'star'){
            nodeRoot = cy.elements()[i];
          }
        }

        for(var i=0; i<cy.elements().size(); i++){
          var element = cy.elements()[i];
          if(element.isNode()){
            element.style('background-color', '#666');
          }
        }

        // split na string que quero testar
        var string_text = $(this).val().split('');
        console.log(string_text);

        var index=0;
        if(visit(index, nodeRoot, string_text)){
          $(this).css('border', '2px solid green'); 
        }else{
          $(this).css('border', '2px solid red');
        }
      });
    });
  });


  // -------------------------
  // GRAMÁTICA REGULAR
  // -------------------------
  $('#add_rule').click(function(event) {
    $('<br><input type="text" />=><input type="text" />').appendTo('#multiple_grammar');
  });
  // var grama = {
  //     S: ['AB', 'BC'],
  //     A: ['BA', 'a'],
  //     B: ['CC', 'b'],
  //     C: ['AB','a']
  // };
  // var w = 'baaba'; 
  var grama = {
    S: ['CB'],
    B: ['CB'],
    C: ['a']
  };
  var w = 'aaa'; 

  var encontrarUmTermo = function(litera, gram){
      var resultado = [];
      for (var r in gram){
        for (var i in gram[r]){
          if(gram[r][i] === litera){
              resultado.push(r);
          }
        }
      }
      return resultado;
  };

  var encontrarTermo = function(tab1, tab2, gram){
      var resultado = [];
      for (var r in gram){
        for (var i in gram[r]){
          if(tab1.indexOf(gram[r][i].charAt(0))>=0 && tab2.indexOf(gram[r][i].charAt(1))>=0){
              resultado.push(r);
          }
        }
      }
      return resultado;
  };

  var cyk = function(word,gram){
    var len = word.length;

    var tab = new Array(len);
    for (var t = 0; t < len; t++) {
      tab[t] = new Array(0);
    }

    for (var z = 0; z<=len-1; z++){
      tab[0][z] = encontrarUmTermo(w.charAt(z), gram);
    }

    for (var j=1; j<=len-1; j++){
      for (var i=0; i<=len-j-1; i++){
        tab[j][i] = [];

        for (var k=0;k<j;k++){
          var pier = j-k-1;
          var drug = i+k+1;
          tab[j][i] = tab[j][i].concat(encontrarTermo(tab[k][i],tab[pier][drug],gram));
        }
      }
    }
    for (var m in tab[len-1][0]){
      if (tab[len-1][0][m] === 'S'){
        return true;
      }
    }
    return false;

    console.log(resultado)
    console.log(resultado.indexOf['S']);
  };

  var test = function(){
    console.log(cyk(w, grama));
  };
  test();
  
</script>
</body>
</html>